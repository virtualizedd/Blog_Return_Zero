<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Return Zero</title>
    <atom:link href="http://virtualizedd.github.io/return-zero/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://virtualizedd.github.io/return-zero</link>
    <description>aventuras en C++ y la programación en general</description>
    <pubDate>Sat, 19 Mar 2016 11:00:00 -0300</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Declarando punteros nulos</title>
      <link>http://virtualizedd.github.io/return-zero/articles/punteros-nulos/</link>
      <pubDate>Sat, 19 Mar 2016 11:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://virtualizedd.github.io/return-zero/articles/punteros-nulos/</guid>
      <author></author>
      <description>&lt;p&gt;Al igual que las variables normales, los punteros no se inicializan cuando se
instancian. A menos que se asigne un valor, un puntero apuntará a algún dirección
basura por defecto.&lt;/p&gt;
&lt;p&gt;Además de direcciones de memoria, hay un valor adicional que pueden almacenar
los punteros: un valor null. Un &lt;strong&gt;valor null&lt;/strong&gt; es un valor especial que significa
que el puntero no está apuntando a nada. A un puntero que almacena un valor null
se le llama un &lt;strong&gt;puntero nulo&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;En C++, podemos asignar un valor null a un puntero inicializándolo con el literal
0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como un puntero null se evalua a 0, se puede usar dentro de una proposición
condicional para verificiar si el puntero es nulo o no:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(ptr)
    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;ptr está apuntando a un valor double.&quot;&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;ptr es un puntero nulo&quot;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Mejor práctica: inicializa tus punteros a un valor null si no les darás otro
valor.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deferenciando punteros nulos&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Deferenciar un puntero basura nos lleva a resultados indefinifidos. El
deferenciar un puntero nulo también nos lleva a comportamiento indefinido. En
la mayoría de los casos, bloqueará tu aplicación.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;el macro NULL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C(pero no C++) define un macro de preprocesador llamado NULL que es #defined como
el valor 0. Incluso aunque no es técnicamente parte de C++, su uso es lo tan
común que debería funcionar en todo compilador de C++.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sin embargo, como NULL es un macro del preprocesador y como no es tecnicámente parte
de C++, la mejor práctica en C++ es evitar usarlo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nullptr en C++11&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nota que el valor 0 no es un tipo de puntero, así que asignarle 0 a un puntero
para denotar que es un puntero nulo es un poco inconsistente. En casos raros,
cuando se usa como argumento literal, puede incluso causar problemas porque el
compilador no puede decidir si nos referimos a un puntero nulo o al entero 0:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;hazAlgo(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//0 es un argumento entero&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;//o un puntero nulo?&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;//(asumirá que es entero)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para encausar estos problemas, C++11 introdujo una nueva palabra clave llamada
&lt;strong&gt;nullptr&lt;/strong&gt;. Esta es tanto una palabra clave como una constante rvalor, al igual
que las palabras claves booleanas true and false.&lt;/p&gt;
&lt;p&gt;Si se trata de C++11, esta palabra clave deberíamos favorecer en lugar del 0
 cuando queramos un puntero nulo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++ convertirá de forma implícita nullptr a cualquier tipo de puntero. Así que
en el ejemplo de arriba, nullptr se convierte implícitamente a un puntero entero,
y luego se le asigna el valor de nullptr(0) a ptr.&lt;/p&gt;
&lt;p&gt;También se puede usar como un literal en una llamada a una función.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;hazAlgo(&lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//este argumento definitivamente&lt;/span&gt;
                  &lt;span class=&quot;comment&quot;&gt;//es un puntero nulo;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Mejor práctica: Con C++11, usa nullptr para inicializar tus punteros a un valor
nulo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;std::nullptr_t en C++11&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++11 también introduce un nuevo tipo llamado std::nullptr_t (en el encabezado&lt;/p&gt;
&lt;p&gt;&lt;cstddef&gt;). std::nullptr_t sólo puede almacenar un valor: nullptr! Aunque esto
puede parecer una tontera, es útil en una situación. Si queremos escribir una
función que acepte un argumento nullptr, ¿de qué tipo hacemos al parámetro?
La respuesta es std::nullptr_t.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hazAlgo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::nullptr_t ptr)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;en hazAlgo()\n&quot;&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Probablemente ni siquiera uses esto, pero es bueno saberlo, tan sólo por 
si acaso.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Una breve introducción a los punteros</title>
      <link>http://virtualizedd.github.io/return-zero/articles/intro-punteros/</link>
      <pubDate>Sat, 19 Mar 2016 11:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://virtualizedd.github.io/return-zero/articles/intro-punteros/</guid>
      <author></author>
      <description>&lt;p&gt;Las variables son una pieza clave de los lenguajes de programación. Es difícil
imaginar la programación sin ellas. Al fin y al cabo, necesitamos de un medio
para leer y escribir datos en memoria, ¿Y qué más sencillo que dar un nombre fácil
de recordar y descriptivo a un espacio de la memoria, y luego simplemente
acceder a ese espacio mediante ese nombre para ya sea leer o escribir el dato
que almacena? Bueno, justamente eso permiten las variables. Cuando nuestro
programa instancia una variable se le asigna automáticamente una dirección de
memoria libre, y cualquier valor que le asignemos se almacena en esta dirección
de memoria. Adicionalmente, lo genial
con las variables es que no hay necesidad de preocuparse de la dirección 
de memoria específica en la que se almacena un valor. Sólo es necesario usar 
el identificador de la variable.
El compilador hará el trabajo de traducir este identificador a la dirección
de memoria que tiene asignada.&lt;/p&gt;
&lt;p&gt;Este enfoque, sin embargo, tiene algunas limitaciones.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operador &amp;amp;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;El operador de dirección (&amp;amp;) nos permite ver la dirección de memoria que tiene
asignada una variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Operador * &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;El operador de deferencia (*) nos permite obtener el valor que almacena una
dirección de memoria en particular.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *&amp;amp;x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Punteros&lt;/strong&gt;
Un &lt;strong&gt;puntero&lt;/strong&gt; es una variable que almacena una dirección de memoria como su 
valor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Declarando un puntero&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Los punteros se declaran como una variable normal, sólo que con un asterisco
entre el tipo de dato y el nombre de la variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *iPtr; &lt;span class=&quot;comment&quot;&gt;//un puntero a un valor entero;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *dPtr; &lt;span class=&quot;comment&quot;&gt;//un puntero a un valor double;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El asterisco aquí no es una deferencia. Es parte de la declaración de síntaxis
del puntero.&lt;/p&gt;
&lt;p&gt;Sintácticamente, C++ aceptará el asterisco después del tipo de dato, o incluso
en el medio. Sin embargo, cuando se declaran múltiples punteros, el asterisco
se debe incluir a cada variable. Es fácil olvidar hacer esto si te acostumbras
a colocar el asterico al tipo en lugar de al nombre de la variable. Sin embargo,
para los retornos es mejor colocar el asterisco al tipo para mejor legibilidad.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *var; &lt;span class=&quot;comment&quot;&gt;//buena practica&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* var; &lt;span class=&quot;comment&quot;&gt;//mala practica&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * var; &lt;span class=&quot;comment&quot;&gt;//mala practica&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{...} &lt;span class=&quot;comment&quot;&gt;//buena practica&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{...} &lt;span class=&quot;comment&quot;&gt;//mala practica&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tal como las variables normales, los punteros no se inicializan cuando se 
declaran. Si no son inicializados, tendrán valores basura.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asignando un valor a un puntero&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dado que los punteros solo almacenan direcciones, cuando les asignamos un valor,
debe ser una dirección. Una de las cosas más comunes de hacer con los punteros
en almacenar en ellos la dirección de memoria de un valor diferente.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = &amp;amp;valor; &lt;span class=&quot;comment&quot;&gt;//puntero inicializado&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Es importante destacar que el tipo del puntero debe coincidir con el tipo del
valor al que apunta.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; iValor = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *iPtr = &amp;amp;iValor; &lt;span class=&quot;comment&quot;&gt;//todo bien&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *dPtr = &amp;amp;iValor; &lt;span class=&quot;comment&quot;&gt;//error!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Además, C++ no te permitirá asignar direcciones de memoria literales a un puntero:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *dPtr = &lt;span class=&quot;number&quot;&gt;0012F&lt;/span&gt;F7C; &lt;span class=&quot;comment&quot;&gt;//no está bien, lo trata como si&lt;/span&gt;
                         &lt;span class=&quot;comment&quot;&gt;//asignaras un entero a un puntero&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;El operación de dirección de memoria retorna un puntero&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vale la pena notar que el operador &amp;amp; no retorna la dirección de memoria de su
operando como un literal, sino que retorna un puntero que contiene a la dirección
del operando, cuyo tipo se deriva del argumento (ej. al tomar la dirección de
un int retornará la dirección en un puntero int).&lt;/p&gt;
&lt;p&gt;Esto se puede observar con el siguiente código:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;
    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;typeid&lt;/span&gt;(&amp;amp;x).name();

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Deferenciando punteros&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Una vez que tenemos un puntero apuntando a algo, la otra cosa común de hacer con
él es deferenciar el puntero para obtener el valor al que apunte. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;valor; &lt;span class=&quot;comment&quot;&gt;//direccion de memoria&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; valor;

&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = &amp;amp;valor;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; ptr; &lt;span class=&quot;comment&quot;&gt;//direccion de memoria&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *ptr; &lt;span class=&quot;comment&quot;&gt;//deferencia al puntero&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esta es la razón por la que los punteros deben tener un tipo. Sin un tipo, un
puntero no sabría cómo interpretar el contenido al que apunta 
cuando es deferenciado. También es la razón por la que el tipo del puntero y de
la dirección de memoria que se le asigna deben coincidir. Si no sucede esto,
cuando el puntero sea deferenciado, malintepretaría los bits como si fueran
de un tipo diferente.&lt;/p&gt;
&lt;p&gt;Una vez asignada una dirección a un puntero, como con cualquier otra variable
se le puede asignar otra dirección a lo largo del programa. Y también es posible
asignar nuevos valores concretos a la dirección de memoria de un puntero
simplemente asignando ese otro valor a su deferencia.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor1 = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor2 = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;

&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = valor1; 
ptr = &amp;amp;valor2 &lt;span class=&quot;comment&quot;&gt;//modificando la direccion&lt;/span&gt;
*prt = &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//similar a valor2 = 40&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;*Una advertencia sobre deferenciar punteros inválidos&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Los punteros en C++ son inherentemente inseguros, y un uso inapropiado de los
punteros es una de las mejores formas de arruinar tu aplicación.&lt;/p&gt;
&lt;p&gt;Cuando se deferencia a un puntero, la aplicación intenta ir a la ubicación de
memoria que está almacenada en el puntero y retirar el contenido de la memoria.
Por razonas de seguridad, los sistemas operativos modernos crean un sandbox
para cada aplicación como forma de prevenir que interactuan inadecuadamente
unas aplicaciones con otras, y así proteger la estabilidad del sistema operativo
mismo. Si una aplicación trata de acceder a una ubicación de memoria que no le
ha sido asignada por el SO, el sistema operativo puede finalizar la aplicación.&lt;/p&gt;
&lt;p&gt;El siguiente programa ilustra esto, y probablemente se bloquee cuando lo ejecutes.
(ve con confianza, no dañarás a tu máquina):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *&amp;amp;p)&lt;/span&gt;
&lt;/span&gt;{
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p; &lt;span class=&quot;comment&quot;&gt;//crea un puntero no inicializado&lt;/span&gt;
    foo(p); &lt;span class=&quot;comment&quot;&gt;//un truco para que el compilador&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;//piense que vamos a asignar a&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;//esto un valor válido &lt;/span&gt;

    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *p; &lt;span class=&quot;comment&quot;&gt;//Deferencia el puntero a valor&lt;/span&gt;
                    &lt;span class=&quot;comment&quot;&gt;//basura.&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;El tamaño de los punteros&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;El tamaño de un puntero depende de la arquitectura para la que se
compila el ejecutable – un ejecutable de 32-bits usa direcciones de memoria
de 32 bits – por lo tanto, un puntero en una máquina de 32bits es de
32 bits(4 bytes). En una de 64bits, el puntero sería de 64 bits (8 bytes).
Esto se cumple independiente de a qué valor apunta.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *chPtr; &lt;span class=&quot;comment&quot;&gt;// chars usualmente son de 1 byte&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *iPtr; &lt;span class=&quot;comment&quot;&gt;// ints usualemente son de 4 bytes&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Algo
{
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nX, nY, nZ;
};
Algo *algunPtr; &lt;span class=&quot;comment&quot;&gt;// Algo es probablemente de 12 bytes&lt;/span&gt;

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(chPtr) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::endl; &lt;span class=&quot;comment&quot;&gt;// imprime 4&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(iPtr) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::endl; &lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(algunPtr) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::endl; &lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como puedes ver, el tamaño de un puntero siempre es el mismo. Esto es porque
el puntero es tan sólo una dirección de memoria, y el número de bits necesarios
para acceder a una dirección de memoria en una máquina determinada siempre
es constante.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Qué hay de bueno con los punteros?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A este punto, los punteros pueden parecer un poco tontos, académico o obtusos.
¿Por qué usar un puntero si tan sólo podemos usar la variable original’&lt;/p&gt;
&lt;p&gt;Resulta que los punteros son útiles en muchos casos distintos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Los arreglos se implementan usando punteros. Los punteros se pueden usar
para iterar a través de un arreglo (como alternativa a los índices del arreglo)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Son la única forma en la que puedes asignar memoria dinámicamente en C++.
Este es por lejos el caso de uso más común para los punteros.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para pasar una enorme cantidad de datos a una función de una
forma que no involucre copiar los datos involucrados, lo cual es ineficiente.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para pasar una función como parámetro a otra función.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para conseguir polimorfismo cuando se trata con herencia.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para tener una clase/struct que apunte a otra clase/struct
para formar una cadena. Esto es útil en algunas estructuras de datos más avanzadas,
tales como las listas enlazadas y los árboles.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Conclusión&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Los punteros son variables que almacenan una dirección de memoria. Se pueden
deferenciar usando el operador (*) para acceder al valor que se almacena en esa
dirección. Deferenciar a un puntero que almacena valor basura puede bloquear
tu aplicación.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;title: Una breve introducción a los punteros
author: CodePaste
date: 2016-03-19 11:00&lt;/p&gt;
&lt;h2 id=&quot;template-article-jade&quot;&gt;template: article.jade&lt;/h2&gt;
&lt;p&gt;Las variables son una pieza clave de los lenguajes de programación. Es difícil
imaginar la programación sin ellas. Al fin y al cabo, necesitamos de un medio
para leer y escribir datos en memoria, ¿Y qué más sencillo que dar un nombre fácil
de recordar y descriptivo a un espacio de la memoria, y luego simplemente
acceder a ese espacio mediante ese nombre para ya sea lee o escribir el dato
que almacena? Bueno, justamente eso permiten las variables. Cuando nuestro
programa instancia a una variable se le asigna automátcamente una dirección de
memoria libre, y cualquier valor que le asignemos se almacena en esta dirección
de memoria. Adicionalmente, lo genial
con las variables es que no hay necesidad de preocuparse de la dirección 
de memoria específica en la que se almacena un valor. Sólo es necesario usar 
el identificador de la variable.
El compilador hará el trabajo de traducir este identificador a la dirección
de memoria que tiene asignada.&lt;/p&gt;
&lt;p&gt;Este enfoque, sin embargo, tiene algunas limitaciones.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operador &amp;amp;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;El operador de dirección (&amp;amp;) nos permite ver la dirección de memoria que tiene
asignada una variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Operador * &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;El operador de deferencia (*) nos permite obtener el valor que almacena una
dirección de memoria en particular.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *&amp;amp;x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Punteros&lt;/strong&gt;
Un &lt;strong&gt;puntero&lt;/strong&gt; es una variable que almacena una dirección de memoria como su 
valor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Declarando un puntero&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Los punteros se declaran como una variable normal, sólo que con un asterisco
entre el tipo de dato y el nombre de la variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *iPtr; &lt;span class=&quot;comment&quot;&gt;//un puntero a un valor entero;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *dPtr; &lt;span class=&quot;comment&quot;&gt;//un puntero a un valor double;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El asterisco aquí no es una deferencia. Es parte de la declaración de síntaxis
del puntero.&lt;/p&gt;
&lt;p&gt;Sintácticamente, C++ aceptará el asterisco después del tipo de dato, o incluso
en el medio. Sin embargo, cuando se declaran múltiples punteros, el asterisco
se debe incluir a cada variable. Es fácil olvidar hacer esto si te acostumbras
a colocar el asterico al tipo en lugar de al nombre de la variable. Sin embargo,
para los retornos es mejor colocar el asterisco al tipo para mejor legibilidad.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *var; &lt;span class=&quot;comment&quot;&gt;//buena practica&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* var; &lt;span class=&quot;comment&quot;&gt;//mala practica&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * var; &lt;span class=&quot;comment&quot;&gt;//mala practica&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{...} &lt;span class=&quot;comment&quot;&gt;//buena practica&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{...} &lt;span class=&quot;comment&quot;&gt;//mala practica&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tal como las variables normales, los punteros no se inicializan cuando se 
declaran. Si no son inicializados, tendrán valores basura.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asignando un valor a un puntero&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dado que los punteros solo almacenan direcciones, cuando les asignamos un valor,
debe ser una dirección. Una de las cosas más comunes de hacer con los punteros
en almacenar en ellos la dirección de memoria de un valor diferente.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = &amp;amp;valor; &lt;span class=&quot;comment&quot;&gt;//puntero inicializado&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Es importante destacar que el tipo del puntero debe coincidir con el tipo del
valor al que apunta.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; iValor = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *iPtr = &amp;amp;iValor; &lt;span class=&quot;comment&quot;&gt;//todo bien&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *dPtr = &amp;amp;iValor; &lt;span class=&quot;comment&quot;&gt;//error!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Además, C++ no te permitirá asignar direcciones de memoria literales a un puntero:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *dPtr = &lt;span class=&quot;number&quot;&gt;0012F&lt;/span&gt;F7C; &lt;span class=&quot;comment&quot;&gt;//no está bien, lo trata como si&lt;/span&gt;
                         &lt;span class=&quot;comment&quot;&gt;//asignaras un entero a un puntero&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;El operación de dirección de memoria retorna un puntero&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vale la pena notar que el operador &amp;amp; no retorna la dirección de memoria de su
operando como un literal, sino que retorna un puntero que contiene a la dirección
del operando, cuyo tipo se deriva del argumento (ej. al tomar la dirección de
un int retornará la dirección en un puntero int).&lt;/p&gt;
&lt;p&gt;Esto se puede observar con el siguiente código:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;
    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;typeid&lt;/span&gt;(&amp;amp;x).name();

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Deferenciando punteros&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Una vez que tenemos un puntero apuntando a algo, la otra cosa común de hacer con
él es deferenciar el puntero para obtener el valor al que apunte. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;valor; &lt;span class=&quot;comment&quot;&gt;//direccion de memoria&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; valor;

&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = &amp;amp;valor;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; ptr; &lt;span class=&quot;comment&quot;&gt;//direccion de memoria&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *ptr; &lt;span class=&quot;comment&quot;&gt;//deferencia al puntero&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esta es la razón por la que los punteros deben tener un tipo. Sin un tipo, un
puntero no sabría cómo interpretar el contenido al que apunta 
cuando es deferenciado. También es la razón por la que el tipo del puntero y de
la dirección de memoria que se le asigna deben coincidir. Si no sucede esto,
cuando el puntero sea deferenciado, malintepretaría los bits como si fueran
de un tipo diferente.&lt;/p&gt;
&lt;p&gt;Una vez asignada una dirección a un puntero, como con cualquier otra variable
se le puede asignar otra dirección a lo largo del programa. Y también es posible
asignar nuevos valores concretos a la dirección de memoria de un puntero
simplemente asignando ese otro valor a su deferencia.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor1 = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; valor2 = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;

&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = valor1; 
ptr = &amp;amp;valor2 &lt;span class=&quot;comment&quot;&gt;//modificando la direccion&lt;/span&gt;
*prt = &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//similar a valor2 = 40&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;*Una advertencia sobre deferenciar punteros inválidos&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Los punteros en C++ son inherentemente inseguros, y un uso inapropiado de los
punteros es una de las mejores formas de arruinar tu aplicación.&lt;/p&gt;
&lt;p&gt;Cuando se deferencia a un puntero, la aplicación intenta ir a la ubicación de
memoria que está almacenada en el puntero y retirar el contenido de la memoria.
Por razonas de seguridad, los sistemas operativos modernos crean un sandbox
para cada aplicación como forma de prevenir que interactuan inadecuadamente
unas aplicaciones con otras, y así proteger la estabilidad del sistema operativo
mismo. Si una aplicación trata de acceder a una ubicación de memoria que no le
ha sido asignada por el SO, el sistema operativo puede finalizar la aplicación.&lt;/p&gt;
&lt;p&gt;El siguiente programa ilustra esto, y probablemente se bloquee cuando lo ejecutes.
(ve con confianza, no dañarás a tu máquina):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *&amp;amp;p)&lt;/span&gt;
&lt;/span&gt;{
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p; &lt;span class=&quot;comment&quot;&gt;//crea un puntero no inicializado&lt;/span&gt;
    foo(p); &lt;span class=&quot;comment&quot;&gt;//un truco para que el compilador&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;//piense que vamos a asignar a&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;//esto un valor válido &lt;/span&gt;

    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *p; &lt;span class=&quot;comment&quot;&gt;//Deferencia el puntero a valor&lt;/span&gt;
                    &lt;span class=&quot;comment&quot;&gt;//basura.&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;El tamaño de los punteros&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;El tamaño de un puntero depende de la arquitectura para la que se
compila el ejecutable – un ejecutable de 32-bits usa direcciones de memoria
de 32 bits – por lo tanto, un puntero en una máquina de 32bits es de
32 bits(4 bytes). En una de 64bits, el puntero sería de 64 bits (8 bytes).
Esto se cumple independiente de a qué valor apunta.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *chPtr; &lt;span class=&quot;comment&quot;&gt;// chars usualmente son de 1 byte&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *iPtr; &lt;span class=&quot;comment&quot;&gt;// ints usualemente son de 4 bytes&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Algo
{
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nX, nY, nZ;
};
Algo *algunPtr; &lt;span class=&quot;comment&quot;&gt;// Algo es probablemente de 12 bytes&lt;/span&gt;

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(chPtr) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::endl; &lt;span class=&quot;comment&quot;&gt;// imprime 4&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(iPtr) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::endl; &lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(algunPtr) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::endl; &lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como puedes ver, el tamaño de un puntero siempre es el mismo. Esto es porque
el puntero es tan sólo una dirección de memoria, y el número de bits necesarios
para acceder a una dirección de memoria en una máquina determinada siempre
es constante.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Qué hay de bueno con los punteros?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A este punto, los punteros pueden parecer un poco tontos, académico o obtusos.
¿Por qué usar un puntero si tan sólo podemos usar la variable original’&lt;/p&gt;
&lt;p&gt;Resulta que los punteros son útiles en muchos casos distintos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Los arreglos se implementan usando punteros. Los punteros se pueden usar
para iterar a través de un arreglo (como alternativa a los índices del arreglo)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Son la única forma en la que puedes asignar memoria dinámicamente en C++.
Este es por lejos el caso de uso más común para los punteros.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para pasar una enorme cantidad de datos a una función de una
forma que no involucre copiar los datos involucrados, lo cual es ineficiente.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para pasar una función como parámetro a otra función.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para conseguir polimorfismo cuando se trata con herencia.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Se pueden usar para tener una clase/struct que apunte a otra clase/struct
para formar una cadena. Esto es útil en algunas estructuras de datos más avanzadas,
tales como las listas enlazadas y los árboles.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Conclusión&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Los punteros son variables que almacenan una dirección de memoria. Se pueden
deferenciar usando el operador (*) para acceder al valor que se almacena en esa
dirección. Deferenciar a un puntero que almacena valor basura puede bloquear
tu aplicación.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Punteros, arreglos, y cómo están relacionados</title>
      <link>http://virtualizedd.github.io/return-zero/articles/punteros-y-arreglos/</link>
      <pubDate>Sat, 19 Mar 2016 11:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://virtualizedd.github.io/return-zero/articles/punteros-y-arreglos/</guid>
      <author></author>
      <description>&lt;p&gt;Punteros y arreglos están relacionados intrínsicamente en C++. Revisemos sus
similitudes.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Cuando declaramos un arreglo fijo de la siguiente forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;para nosotros esto es un arreglo de 5 enteros, pero para el compilador, un 
arreglo es una variable de tipo int[5]. Sabemos qué son los valores 
arreglo[0], arreglo[1], arreglo[2], … arreglo[4] (1, 2, 3, … 4, respectivamente).
¿Pero qué valor tiene el arreglo mismo?.&lt;/p&gt;
&lt;p&gt;La variable arreglo contiene la dirección del primer elemento del arreglo, como si
fuera un puntero! Puedes observar esto en el siguiente programa:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;};

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;El arreglo tiene dirección: &quot;&lt;/span&gt; &amp;lt;&amp;lt; arreglo &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;El elemento 0 tiene dirección: &quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;arreglo[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nota que la dirección almacenada por la variable arreglo es la misma dirección
del primer elemento del arreglo.&lt;/p&gt;
&lt;p&gt;Es una falacia común creer que un arreglo y un puntero al arreglo son idénticos.
No lo son. AUnque ambos apuntan al primer elemento del arreglo, tienen diferente
tipo de información. En el caso de arriba, el arreglo es de tipo int[5], mientras
que un puntero sería de tipo int *. Veremos dentro de poco donde está la diferencia.&lt;/p&gt;
&lt;p&gt;La confusión se debe principalmente al hecho de que en muchos casos, cuando se
evalua un arreglo fijo, esté “decaerá” (se convertiá implícitamente) en un puntero
al primer elemento del arreglo (esencialmente, perdiendo su información de tipo).&lt;/p&gt;
&lt;p&gt;Sin embargo, esto también nos permite tratar a los arreglos fijos y a los punteros
de forma idéntica en la mayoría de los casos.&lt;/p&gt;
&lt;p&gt;Por ejemplo, podemos deferenciar el arreglo para obtener el valor del primer 
elemento:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;};

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *arreglo;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nota que no estamos &lt;em&gt;en realidad&lt;/em&gt; deferenciando al array mismo. El arreglo (de
tipo int[5]) obtiene es convertido de forma implícita a un puntero (de tipo
int *), y deferenciamos el puntero para obtener el valor en la dirección de memoria
que almacena el puntero (el valor del primer elemento del arreglo).&lt;/p&gt;
&lt;p&gt;También podemos asignar un puntero para que apunte a un arreglo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;}

&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;;

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *ptr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esto funciona porque el array decae a un puntero de tipo int *, y nuestro
puntero (también de tipo int *) tiene el mismo tipo.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diferencias entre punteros y arreglos fijos&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hay unas cuántos casos donde escribir un arreglo fijo y un puntero hace una
diferencia. Estos casos ayudan a ilustrar que un arreglo fijo y un puntero no
son lo mismo.&lt;/p&gt;
&lt;p&gt;La principal diferencia ocurre cuando se usa el operador &lt;code&gt;sizeof()&lt;/code&gt;. Cuando se usa
sobre un arreglo fijo, &lt;code&gt;sizeof&lt;/code&gt; retorna el tamaño del arreglo completo (el tamaño
de un elemento por la longitud del arreglo). Cuando se usa sobre un puntero,
&lt;code&gt;sizeof&lt;/code&gt; retorna el tamaño de una dirección de memoria (en bytes). &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;};

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(arreglo) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//tamaño del arreglo&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr = &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;;

&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(ptr) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//tamaño del puntero&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Un arreglo fijo sabe cómo de largo es el arreglo al que apunta. Un puntero al
arreglo no lo sabe.&lt;/p&gt;
&lt;p&gt;La segunda diferencia ocurre cuando se usa el operador &amp;amp;. Al tomar la dirección
de memoria de un puntero obtenemos la dirección de memoria de la variable puntero.
Al tomar la dirección de memoria de un arreglo obtenemos un puntero al arreglo
completo. Este puntero también apunta al primer elemento del arreglo, pero el
tipo de información es diferente (en el ejemplo de arriba &lt;code&gt;int(*)[5]&lt;/code&gt;). Es poco
probable que necesites usar esto.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pasando arreglos fijos a funciones&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dado que copiar arreglos puede ser algo muy costoso, C++ no copia un arreglo cuando
se le pasa a una función. En vez de eso, el arreglo fijo decae a un puntero, y el
puntero se pasa a la función.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;imprimirSize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *arreglo)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(arreglo) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;};

    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(arreglo) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
    imprimirSize(arreglo);

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eso sucede incluso si el parámetro se declara como un arreglo fijo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;imprimirSize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[])&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(arreglo) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;};

    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(arreglo) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;
    imprimirSize(arreglo);

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este último ejemplo, C++ convierte implícitamente los parámetros usando la
síntaxis de arreglos ([]) a la sintaxis de punteros (*), Eso significa que las
dos declaraciones siguientes son idénticas.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;imprimirSize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[])&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;imprimirSize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *arreglo)&lt;/span&gt;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Algunos programadores prefieren usar [] ya que hace más claro que la función 
está esperando un arreglo. Sin embargo, en la mayoría de los casos, cómo el
puntero no sabe cómo de largo es el arreglo, necesitarás pasar el tamaño del
arreglo como un argumento separado de cualquier forma (los strings son una
excepción porque acaban con null).&lt;/p&gt;
&lt;p&gt;Recomendamos usar la síntaxis de punteros, porque deja más claro que los parámetros
son tratados como punteros, y no como arreglos fijos, y que en ciertas operaciones,
como &lt;code&gt;sizeof()&lt;/code&gt;, operará como un puntero.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Un poco sobre pasar por referencia/dirección&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;El hecho de que los arreglos decaen a puntero cuando se pasan a una función
explica la razón por la cual al cambiar un arreglo en una función también se
cambia el arreglo que se pasa como argumento. Considera el siguiente
ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cambiarArreglo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ptr)&lt;/span&gt;
&lt;/span&gt;{
    *ptr = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;
}

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arreglo[] = {&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;};

    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;El elemento 0 tiene valor: &quot;&lt;/span&gt; &amp;lt;&amp;lt; arreglo[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;

    cambiarArreglo(arreglo);

    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;El elemento 0 tiene valor: &quot;&lt;/span&gt; &amp;lt;&amp;lt; arreglo[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;'\n'&lt;/span&gt;;

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cuando se llama a cambiarArreglo, el arreglo decae a un puntero, y el valor
de ese puntero (la dirección de memoria del primer elemento del arreglo) se
copia en el parámetro ptr de la función. Aunque el valor de ptr es una copia
de la dirección de memoria del arreglo, apunta al arreglo real (no a una copia!).
Por lo tanto, cuando se deferencia a ptr, se deferencia al arreglo real!.&lt;/p&gt;
&lt;p&gt;Los lectores astutos notarán que este fenómeno también ocurre con punteros
a valores que no son arreglos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Los arreglos de structs y clases no decaen&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Finalmente, vale destacar que los arreglos que son partes de structs o clases no
decaen cuando el struct o la clase completa se pasan a una función. Esto
nos lleva a una forma útil de prevenir que decaigan si así lo queremos,  y que
será valiosa cuando escribamos clases que usan arreglos.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Definiendo funciones no tipadas con el uso plantillas</title>
      <link>http://virtualizedd.github.io/return-zero/articles/plantillas-funciones/</link>
      <pubDate>Fri, 18 Mar 2016 15:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://virtualizedd.github.io/return-zero/articles/plantillas-funciones/</guid>
      <author></author>
      <description>&lt;p&gt;Como con cualquier otro lenguaje de tipado estático, cuando escribimos programas
en C++ estamos obligados a especificar siempre los tipos de nuestras variables,
pues de otro modo el programa no compilará. Esta característica, por supuesto,
incluye sus ventajas. En especial, significa ahorrarle a la máquina que tipifique
las variables en tiempo de ejecución, y por lo tanto, obtener una mejor 
eficiencia. Pero similar a casi cualquier otra ventaja, también significa dar
algo a cambio. En este caso, es a costa de la potencial flexibilidad que se puede
observar en lenguajes de tipado dinámico como Python o Ruby.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Por ejemplo, digamos que quisieras escribir una función que calcule el máximo
de dos números. Podrías hacerlo de esta forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nX, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nY)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (nX &amp;gt; nY) ? nX : nY;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esta función funcionaría bien – pero con enteros. ¿Qué sucede si más tarde
te das cuenta que necesitas que tu función funcione con doubles? Tradicionalmente,
la respuesta sería sobrecargar la función max() y crear una nueva versión
que funcione con doubles:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; dX, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; dY)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (dX &amp;gt; dY) ? dX : dY;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nota que el código para la implementación de la versión con doubles es exactamente
el mismo que para la versión con enteros! De hecho, esta implementación funcionaría
con toda suerte de tipos distintos: chars, ints, doubles y si has sobrecargado el 
operador &amp;gt;, incluso con clases! Sin embargo, como C++ te exige hacer a tus variables
de tipos especificos, te atascas escribiendo una función para cada tipo que quieras
usar.&lt;/p&gt;
&lt;p&gt;Tener que especificar distintos “sabores” de la misma función,
donde lo único que cambia es el tipo de los parámetros se puede convertir en un severo
dolor de cabeza y un desperdicio de tiempo, además que va en contra del consejo
de programación general de que se debería minimizar la duplicación de código tanto
como sea posible. ¿No sería genial si pudieramos escribir una versión de max() que
fuera capaz de trabajar con parámetro de CUALQUIER tipo?&lt;/p&gt;
&lt;p&gt;Aquí es donde aparecen las plantillas de funciones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Qué es una plantilla de función?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Si buscases la palabra “plantilla” en el diccionario, encontrarías una definición
similar a la siguiente: “una plantilla es un modelo que sirve como un patrón para
crear objetos similares”. Un tipo de plantilla que es muy fácil de comprender son
los stencils. Un stencil es un objeto (ej. un trozo de cartón) con una forma
recortada (ej. la letra J). Colocando el stencil sobre otro objeto, luego de 
pintar con un spray a través del agujero, puedes producir patrones estencilados
muy rápidamente en muchos colores diferentes! Nota que sólo necesitas crear un
stencil determinado una sola vez - luego puedes usarlo tantas veces como quieras
crear patrones estencilados en cualquier color(es) que quieras. Incluso mejor,
no tienes que decidir el color del patrón estencilado hasta que decides
realmente usar el estencil.&lt;/p&gt;
&lt;p&gt;En C++, las plantillas de funciones, son funciones que sirven como un patrón para
crear otras funciones similares. La idea básica detrás de las plantillas de 
funciones es crear una función sin tener que especificar el(los) tipo(s) exacto(s)
de algunas o todas las variables. En vez de eso, definimos la función usando 
espacios reservados llamados parámetros de tipo de la plantilla. Una vez que 
creamos una función usando estos espacios reservados para los tipos, creamos
efectivamente una “función estencil”.&lt;/p&gt;
&lt;p&gt;Resulta que no puedes llamar a una plantilla de función directamente – esto 
se debe a que el compilador no sabe cómo manejar los espacios reservados para
los tipos directamente. En su lugar, cuando llamamos a una plantilla de función,
el compilador “genera un estencil” de la plantilla, reemplazando los espacios
reservados para los tipos con los tipos de variable real en tu llamada a la
función! Usando esta metodología, el compilador puede crear múltiples “sabores”
de una función desde una plantilla!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Creando plantillas de funciones en C++&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ya te debes estar preguntando cómo crear plantillas de funciones en C++. Resulta
que no es del todo difícil.&lt;/p&gt;
&lt;p&gt;Revisemos la versión de max() con enteros nuevamente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nX, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nY)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (nX &amp;gt; nY) ? nX : nY;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nota que hay 3 lugares donde se usan tipos especificos: para los parámetros nX, nY,
y el valor de retorno está especificado que deben ser enteros. Para crear una
plantilla de función, vamos a reemplazar estos tipos especificos con espacios
reservados para tipos. En este caso, dado que sólo tenemos un tipo que necesita
reemplazarse (int), solo necesitamos un parámetro de tipo para la plantilla.
Llamemos a nuestro espacio reservado para tipos “Type”. Puedes nombrar a tu 
espacio reservado para tipos de casi cualquier forma que quieras, siempre que 
no sea una palabra reservada. Aquí está nuestra función con un espacio reservado
para tipos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;function&quot;&gt;Type  &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Type tX, Type tY)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (tX &amp;gt; tY) ? tX : tY;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Nota: También cambié la notación húngara de las variables para que reflejen que
ya no son necesariamente enteros - son de cualquier tipo Type que indiquemos!)&lt;/p&gt;
&lt;p&gt;Este es un buen comienzo - sin embargo, no compilará porque el compilador no sabe
que significa “Type”! Con el fin de decirle al compilador que Type es un espacio
reservado para tipos, necesitamos decirle formalmente al compilador que Type es
un parámetro de tipo plantilla. Aquí es donde se usa la llamada &lt;strong&gt;declaración
de parámetros de plantilla&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; Type&amp;gt; &lt;span class=&quot;comment&quot;&gt;// &amp;lt;= declaración de los parámetros&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;Type  &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Type tX, Type tY)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (tX &amp;gt; tY) ? tX : tY;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Creelo o no, estamos listos! Esto compilará!&lt;/p&gt;
&lt;p&gt;Ahora, miremos más de cerca la declaración de parámetros del template. Comenzamos
con la palabra clave &lt;em&gt;template&lt;/em&gt; - esto le dice al compilador que lo que sigue
va a ser una lista de parámetros de plantilla. Colocamos todos nuestros parámetros
dentro de paréntesis angulares (&amp;lt; &amp;gt;). Para crear un parámetro de tipo de la plantilla
usamos ya sea la palabra clave &lt;em&gt;typename&lt;/em&gt; o &lt;em&gt;class&lt;/em&gt;. No hay diferencia entre las
dos palabras claves en este contexto, y usualmente verás a gente usando la 
palabra clave class. Sin embargo, preferimos la palabra clave más nueva typename,
ya que deja más claro que el parámetro de tipo de la plantilla no tiene que ser
una clase. Después de la palabra clave typename o class, todo lo que queda es
seleccionar un nombre para el espacio reservado para el tipo. Tradicionalmente,
con funciones que sólo tienen un parámetro de tipo en la plantilla, se usa el
nombre “Type” (a menudo abrevido a “T”). Si la plantilla de función usa múltiples
parámetros de tipo en la plantilla, pueden ir separados por coma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T1, &lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T2&amp;gt;
&lt;span class=&quot;comment&quot;&gt;//plantilla de la función aquí&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Usando plantillas de funciones&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Usar una plantilla de función es extremadamente sencillo - tan solo tienes que
usarla como con cuaqluier otra función.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nValor = max(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//retorna 7&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; dValor = max(&lt;span class=&quot;number&quot;&gt;6.34&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;18.523&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//retorna 18.523&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; chValor = max(&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'6'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//retorna 'a'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nota que todas estas tres llamadas a max() tienen parámetros de distintos tipos!&lt;/p&gt;
&lt;p&gt;Como puedes ver, las plantillas de funciones puede ahorrarte un montón de tiempo,
porque sólo necesitas escribir una función, y funcionará con muchos tipos distintos.
Una vez que te acostumbras a escribir plantillas de funciones, encontrarás que 
en realidad no toma más tiempo que escribir funciones con tipos reales. Las plantillas
de funciones reducen la mantención de código, porque el código duplicado se reduce
significativamente. Y finalmente, las plantillas de funciones pueden ser más seguras,
porque no hay necesidad de copiar las funciones y cambiar los tipos a mano
cuando sea que necesites que la función funciones con un tipo nuevo!&lt;/p&gt;
&lt;p&gt;Las plantillas de funciones tienen unas pocas desventajas, y sería &amp;lt;&amp;gt; no
mencionarlas. En primer lugar, los compiladores más antiguos no tienen muy buen
soporte para las plantillas. Sin embargo, los compiladores modernos son mucho
mejores en soportar y implementar apropiadamente la funcionalidad de plantillas.
En segundo lugar, las plantillas de funciones producen mensajes de error que se
ven de locos y que son mucho más complicados de descifrar que aquellos de las
funciones regulares. Sin embargo, estas desventajas son menores comparadas con
la potencia y flexibilidad que brindan las plantillas a tu kit de herramientas
de programación!&lt;/p&gt;
&lt;p&gt;Nota: La librería estándar ya viene con una función max() en forma de plantilla. 
Si usas la instrucción “using namespace std;” el compilador será incapaz de
decir si quieres tu versión de max() o la de std::max(). &lt;/p&gt;
</description>
    </item>
  </channel>
</rss>