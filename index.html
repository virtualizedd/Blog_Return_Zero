<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Return Zero
    </title>
    <link rel="alternate" href="http://virtualizedd.github.io/return-zero/feed.xml" type="application/rss+xml" title="aventuras en C++ y la programación en general">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="http://virtualizedd.github.io/return-zero/css/main.css">
  </head>
  <body>
    <header class="header">
      <div class="content-wrap">
        <div class="logo">
          <h1><a href="http://virtualizedd.github.io/return-zero">Return Zero</a></h1>
          <p class="description">aventuras en C++ y la programación en general</p>
        </div>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article intro">
          <header>
            <p class="date"><span>19. March 2016</span></p>
            <h2><a href="http://virtualizedd.github.io/return-zero/articles/punteros-nulos/">Declarando punteros nulos</a></h2>
          </header>
          <section class="content"><p>Al igual que las variables normales, los punteros no se inicializan cuando se
instancian. A menos que se asigne un valor, un puntero apuntará a algún dirección
basura por&nbsp;defecto.</p>
<p>Además de direcciones de memoria, hay un valor adicional que pueden almacenar
los punteros: un valor null. Un <strong>valor null</strong> es un valor especial que significa
que el puntero no está apuntando a nada. A un puntero que almacena un valor null
se le llama un <strong>puntero nulo</strong>.</p>
<p>
            <p class="more"><a href="http://virtualizedd.github.io/return-zero/articles/punteros-nulos/">leer más</a></p>
          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>18. March 2016</span></p>
            <h2><a href="http://virtualizedd.github.io/return-zero/articles/plantillas-funciones/">Definiendo funciones no tipadas con el uso plantillas</a></h2>
          </header>
          <section class="content"><p>Como con cualquier otro lenguaje de tipado estático, cuando escribimos programas
en C++ estamos obligados a especificar siempre los tipos de nuestras variables,
pues de otro modo el programa no compilará. Esta característica, por supuesto,
incluye sus ventajas. En especial, significa ahorrarle a la máquina que tipifique
las variables en tiempo de ejecución, y por lo tanto, obtener una mejor 
eficiencia. Pero similar a casi cualquier otra ventaja, también significa dar
algo a cambio. En este caso, es a costa de la potencial flexibilidad que se puede
observar en lenguajes de tipado dinámico como Python o&nbsp;Ruby.

            <p class="more"><a href="http://virtualizedd.github.io/return-zero/articles/plantillas-funciones/">leer más</a></p>
          </section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="http://virtualizedd.github.io/return-zero/archive.html">« Archivos</a>
        </div>
        <section class="about">
        </section>
        <section class="copy">
          <p>&copy; 2016 Virtualedd &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>